<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hex Dice Wars with Enhanced AI Personalities</title>
  <style>
    /* ----------------------------------------------
       BASIC RESET & LAYOUT (styled similarly to DiceWarsJS)
    ---------------------------------------------- */
    html, body {
      margin: 0;
      padding: 0;
      background: #eeeeee;        /* light gray background */
      color: #333333;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
      text-align: center;
      height: 100vh;
      overflow: hidden;
    }

    #controls {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
    }

    #controls label {
      font-size: 16px;
      color: #333333;
    }

    #controls select,
    #controls button {
      padding: 6px 12px;
      font-size: 16px;
      background: #f0f0f0;
      border: 2px solid #aaaaaa;
      color: #333333;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s, border-color 0.2s;
    }
    #controls select:hover:not(:disabled),
    #controls button:hover:not(:disabled) {
      background: #e0e0e0;
      border-color: #888888;
    }
    #controls button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #gameContainer {
      display: inline-block;
      margin-top: 12px;
      position: relative;
    }

    /* Canvas styled to mimic DiceWarsJS white background */
    canvas {
      background: #ffffff;
      border: 2px solid #cccccc;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      display: block;
      margin: 0 auto;
    }

    #uiBar {
      margin-top: 12px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
    }

    #uiBar button {
      padding: 8px 16px;
      font-size: 16px;
      background: #f0f0f0;
      border: 2px solid #aaaaaa;
      color: #333333;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s, border-color 0.2s;
    }
    #uiBar button:hover:not(:disabled) {
      background: #e0e0e0;
      border-color: #888888;
    }
    #uiBar button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #statusText {
      font-size: 16px;
      color: #555555;
    }

    /* Dice result banner at bottom */
    #diceResult {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: #ffffff;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 18px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 100;
    }
    #diceResult.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Controls: select number of AI, regenerate map -->
  <div id="controls">
    <label for="aiCountSelect">Number of AI Players:</label>
    <select id="aiCountSelect">
      <option value="1">1 AI</option>
      <option value="2">2 AI</option>
      <option value="3">3 AI</option>
      <option value="4">4 AI</option>
      <option value="5">5 AI</option>
    </select>
    <button id="newMapBtn">Generate New Map</button>
  </div>

  <!-- Game container: canvas + end-turn button -->
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="uiBar">
      <button id="endTurnBtn">End Turn</button>
      <span id="statusText">Loading…</span>
    </div>
  </div>

  <!-- Dice result banner -->
  <div id="diceResult"></div>

  <script>
  (function() {
    /**********************************
     * CONFIGURATION
     **********************************/
    const ROWS = 20;               // Reduced to 20
    const COLS = 30;               // Reduced to 30
    let NUM_PLAYERS = 1 + 1;       // 1 human + selected AI
    const FULL_PLAYER_COLORS = [
      '#3B83BD', // Player 1 (Human) – blue
      '#BD3B3B', // AI 2 – red
      '#3BBD3B', // AI 3 – green
      '#BDBD3B', // AI 4 – yellow
      '#8A2BE2', // AI 5 – blue-violet
      '#FFA500'  // AI 6 – orange
    ];
    let PLAYER_COLORS = FULL_PLAYER_COLORS.slice(0, NUM_PLAYERS);

    const WATER_COLOR = '#D0EFFF'; // lighter blue for water

    const FPS = 30;                // Frames per second
    const ANIM_FRAMES = 15;        // Frames for dice animation

    // Map generation parameters
    const SEED_COUNT = Math.max(1, Math.floor((ROWS * COLS) * 0.04)); // ~4% seeds
    const GROWTH_ITERATIONS = 6;    // Number of growth passes
    const MAP_TRIALS = 30;          // Candidate maps to evaluate

    // Adjacency directions (4-way)
    const DIRS = [
      [-1,  0], // north
      [ 1,  0], // south
      [ 0, -1], // west
      [ 0,  1]  // east
    ];

    // AI personalities
    const PERSONALITIES = ['Aggressor', 'Turtle', 'Opportunist', 'Scavenger'];

    /**********************************
     * GAME STATE
     **********************************/
    let landGrid = null;    // 2D boolean: true=land, false=water
    let territories = [];   // length = ROWS*COLS, { owner: -2| -1 | 0..NUM_PLAYERS-1, dice: int }
                           // owner = -2 → neutral ruin, -1 → water, ≥0 → player index
    let currentPlayer = 0;  // 0=human, 1..NUM_PLAYERS-1=AI
    let selectedIndex = null;
    let gameOver = false;
    let winner = null;

    // Animation state for attack (null if idle)
    let anim = null;
    // anim = {
    //   attackerIdx, defenderIdx,
    //   framesLeft,
    //   A_dice, D_dice,
    //   finalAttackerRolls, finalDefenderRolls,
    //   attackerSum, defenderSum,
    //   finalDisplayed: false
    // };

    // AI personalities array, index 0='Human'
    let AI_PERSONALITIES = [];

    /**********************************
     * CANVAS SETUP
     **********************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    // Compute hex dimensions to fit COLS × ROWS in 800×600
    const HEX_RADIUS = Math.floor((canvasWidth / (COLS + 0.5)) / Math.sqrt(3));
    const HEX_WIDTH  = Math.sqrt(3) * HEX_RADIUS;
    const HEX_HEIGHT = 2 * HEX_RADIUS;
    const V_SPACING  = HEX_HEIGHT * 0.75;  // vertical spacing
    const gridWidth  = (COLS * HEX_WIDTH) + (HEX_WIDTH / 2);
    const gridHeight = ((ROWS - 1) * V_SPACING) + HEX_HEIGHT;
    const xOffset    = (canvasWidth  - gridWidth)  / 2;
    const yOffset    = (canvasHeight - gridHeight) / 2;

    /**********************************
     * UI ELEMENTS
     **********************************/
    const aiCountSelect = document.getElementById('aiCountSelect');
    const newMapBtn     = document.getElementById('newMapBtn');
    const endTurnBtn    = document.getElementById('endTurnBtn');
    const statusText    = document.getElementById('statusText');
    const diceResultDiv = document.getElementById('diceResult');

    /**********************************
     * MAP GENERATION FUNCTIONS
     **********************************/

    function createEmptyGrid(rows, cols) {
      const grid = new Array(rows);
      for (let r = 0; r < rows; r++) {
        grid[r] = new Array(cols).fill(false);
      }
      return grid;
    }

    // Remove isolated land tiles (no adjacent land) to avoid one‐cell islands
    function removeIsolatedLand(grid) {
      const rows = grid.length, cols = grid[0].length;
      const toRemove = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (!grid[r][c]) continue;
          let count = 0;
          for (const [dr, dc] of DIRS) {
            const nr = r + dr, nc = c + dc;
            if (
              nr >= 0 && nr < rows &&
              nc >= 0 && nc < cols &&
              grid[nr][nc]
            ) {
              count++;
            }
          }
          if (count === 0) {
            toRemove.push([r, c]);
          }
        }
      }
      for (const [r, c] of toRemove) {
        grid[r][c] = false;
      }
    }

    function generateLandMap(rows, cols, seedCount, growthIterations) {
      // 1) Start all water
      const land = createEmptyGrid(rows, cols);

      // 2) Place seedCount land seeds randomly
      for (let i = 0; i < seedCount; i++) {
        const r = Math.floor(Math.random() * rows);
        const c = Math.floor(Math.random() * cols);
        land[r][c] = true;
      }

      // 3) Growth passes
      for (let pass = 0; pass < growthIterations; pass++) {
        const newLand = land.map(row => row.slice());
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (land[r][c]) continue; // already land
            let neighbors = 0;
            for (const [dr, dc] of DIRS) {
              const nr = r + dr, nc = c + dc;
              if (
                nr >= 0 && nr < rows &&
                nc >= 0 && nc < cols &&
                land[nr][nc]
              ) {
                neighbors++;
              }
            }
            if (neighbors === 0) continue;
            const p = 1 - Math.pow(0.6, neighbors);
            if (Math.random() < p) {
              newLand[r][c] = true;
            }
          }
        }
        // Commit and remove isolated
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            land[r][c] = newLand[r][c];
          }
        }
        removeIsolatedLand(land);
      }

      removeIsolatedLand(land);
      return land;
    }

    function computeMapComplexity(grid) {
      const rows = grid.length, cols = grid[0].length;
      let totalLandTiles = 0, peninsulaCount = 0, coastLength = 0, regionCount = 0;

      // Count land, peninsulas, coastline
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (!grid[r][c]) {
            for (const [dr, dc] of DIRS) {
              const nr = r + dr, nc = c + dc;
              if (
                nr >= 0 && nr < rows &&
                nc >= 0 && nc < cols &&
                grid[nr][nc]
              ) {
                coastLength++;
              }
            }
            continue;
          }
          totalLandTiles++;
          let landNbrs = 0;
          for (const [dr, dc] of DIRS) {
            const nr = r + dr, nc = c + dc;
            if (
              nr >= 0 && nr < rows &&
              nc >= 0 && nc < cols &&
              grid[nr][nc]
            ) {
              landNbrs++;
            }
          }
          if (landNbrs === 1) peninsulaCount++;
        }
      }

      // Count regions via flood-fill
      const visited = createEmptyGrid(rows, cols);
      function floodFill(sr, sc) {
        const stack = [[sr, sc]];
        visited[sr][sc] = true;
        while (stack.length) {
          const [cr, cc] = stack.pop();
          for (const [dr, dc] of DIRS) {
            const nr = cr + dr, nc = cc + dc;
            if (
              nr >= 0 && nr < rows &&
              nc >= 0 && nc < cols &&
              grid[nr][nc] && !visited[nr][nc]
            ) {
              visited[nr][nc] = true;
              stack.push([nr, nc]);
            }
          }
        }
      }
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[r][c] && !visited[r][c]) {
            regionCount++;
            floodFill(r, c);
          }
        }
      }

      // Combine into complexity score
      const W_COAST     = 0.6;
      const W_REGIONS   = -0.8;
      const W_PENINSULA = 0.4;
      const W_LAND      = 0.2;

      const normLand      = totalLandTiles / (rows * cols);
      const normCoast     = coastLength / (rows * cols * 2);
      const normRegions   = regionCount > 0 ? 1 / regionCount : 0;
      const normPeninsula = peninsulaCount / (rows * cols);

      const score =
        (W_COAST     * normCoast) +
        (W_REGIONS   * normRegions) +
        (W_PENINSULA * normPeninsula) +
        (W_LAND      * normLand);

      return { totalLandTiles, peninsulaCount, coastLength, regionCount, score };
    }

    function findBestMap(rows, cols, seedCount, growthIterations, trials) {
      let bestGrid = null, bestScore = -Infinity;
      for (let t = 0; t < trials; t++) {
        const candidate = generateLandMap(rows, cols, seedCount, growthIterations);
        const metrics = computeMapComplexity(candidate);
        if (metrics.regionCount === 1 && metrics.score > bestScore) {
          bestScore = metrics.score;
          bestGrid = candidate.map(row => row.slice());
        }
      }
      if (!bestGrid) {
        while (true) {
          const candidate = generateLandMap(rows, cols, seedCount, growthIterations);
          const metrics = computeMapComplexity(candidate);
          if (metrics.regionCount === 1) {
            bestGrid = candidate;
            break;
          }
        }
      }
      return bestGrid;
    }

    /**********************************
     * GAME INITIALIZATION
     **********************************/
    function initGame() {
      // 1) Generate connected land grid
      landGrid = findBestMap(
        ROWS, COLS,
        SEED_COUNT, GROWTH_ITERATIONS,
        MAP_TRIALS
      );

      // 2) Initialize territories[]
      territories = new Array(ROWS * COLS).fill(null).map(() => ({ owner: -1, dice: 0 }));

      // First collect all land‐eligible indices
      const landIndices = [];
      for (let idx = 0; idx < ROWS * COLS; idx++) {
        const r = Math.floor(idx / COLS), c = idx % COLS;
        if (landGrid[r][c]) {
          landIndices.push(idx);
        }
      }

      // Shuffle land indices, then deal in round‐robin to players
      shuffleArray(landIndices);
      let pi = 0; // player index to assign
      for (const idx of landIndices) {
        territories[idx].owner = pi;
        // Assign initial dice randomly between 1 and 8
        territories[idx].dice = Math.floor(Math.random() * 8) + 1;
        pi = (pi + 1) % NUM_PLAYERS;
      }

      // 3) Place neutral ruins on ~2% of the land tiles
      const ruinCount = Math.max(1, Math.floor(landIndices.length * 0.02));
      for (let i = 0; i < ruinCount; i++) {
        const ruinIdx = landIndices[i];
        territories[ruinIdx].owner = -2;
        territories[ruinIdx].dice = 0;
      }

      // 4) Assign AI personalities
      AI_PERSONALITIES = new Array(NUM_PLAYERS).fill('Human');
      for (let i = 1; i < NUM_PLAYERS; i++) {
        AI_PERSONALITIES[i] = PERSONALITIES[(i - 1) % PERSONALITIES.length];
      }

      currentPlayer = 0;
      selectedIndex = null;
      gameOver = false;
      winner = null;
      anim = null;
      PLAYER_COLORS = FULL_PLAYER_COLORS.slice(0, NUM_PLAYERS);
      updateStatus();
      draw();
    }

    // Utility: shuffle array in‐place
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    /**********************************
     * DRAWING
     **********************************/
    function draw() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const idx = r * COLS + c;
          const cell = territories[idx];
          const { centerX, centerY } = hexCenter(r, c);

          if (cell.owner === -1) {
            // Water
            drawHexagon(centerX, centerY, HEX_RADIUS, WATER_COLOR);
          } else if (cell.owner === -2) {
            // Neutral ruin: gray hex with "★"
            drawHexagon(centerX, centerY, HEX_RADIUS, '#AAAAAA');
            ctx.fillStyle = '#000000';
            ctx.font = `${Math.floor(HEX_RADIUS * 0.8)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('★', centerX, centerY);
          } else {
            // Player land
            drawHexagon(centerX, centerY, HEX_RADIUS, PLAYER_COLORS[cell.owner]);
            if (
              idx === selectedIndex &&
              currentPlayer === 0 &&
              !gameOver &&
              !anim
            ) {
              drawHexagonOutline(centerX, centerY, HEX_RADIUS, '#FFFFFF', 3);
            }
            ctx.fillStyle = '#000000';
            ctx.font = `${Math.floor(HEX_RADIUS * 0.9)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(cell.dice, centerX, centerY);
          }
        }
      }

      if (anim) {
        drawDiceAnimation();
      }
    }

    function hexCenter(r, c) {
      const centerX = xOffset + HEX_WIDTH * (c + 0.5 + 0.5 * (r % 2));
      const centerY = yOffset + HEX_RADIUS + r * V_SPACING;
      return { centerX, centerY };
    }

    function drawHexagon(cx, cy, r, fillColor) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = -Math.PI / 2 + (i * Math.PI / 3);
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.strokeStyle = '#555555';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function drawHexagonOutline(cx, cy, r, strokeColor, lineWidth) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = -Math.PI / 2 + (i * Math.PI / 3);
        const x = cx + r * Math.cos(angle);
        const y = cy + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = lineWidth;
      ctx.stroke();
    }

    /**********************************
     * STATUS & TURN MANAGEMENT
     **********************************/
    function updateStatus() {
      if (gameOver) {
        statusText.textContent = `Player ${winner + 1} wins!`;
        endTurnBtn.disabled = true;
        return;
      }
      if (currentPlayer === 0) {
        statusText.textContent =
          'Your turn (Blue). Select a land hex with ≥2 dice to attack or click "End Turn".';
        endTurnBtn.disabled = !!anim;
      } else {
        const personality = AI_PERSONALITIES[currentPlayer];
        statusText.textContent = `AI Player ${currentPlayer + 1} (${personality}) is thinking…`;
        endTurnBtn.disabled = true;
        setTimeout(() => { aiTurn(currentPlayer); }, 500);
      }
    }

    function endHumanTurn() {
      if (gameOver || currentPlayer !== 0 || anim) return;
      selectedIndex = null;
      reinforce(currentPlayer);
      advanceToNextPlayer();
    }

    function advanceToNextPlayer() {
      let next = (currentPlayer + 1) % NUM_PLAYERS;
      let iter = 0;
      while (!hasTerritories(next) && iter < NUM_PLAYERS) {
        next = (next + 1) % NUM_PLAYERS;
        iter++;
      }
      currentPlayer = next;
      checkGameOver();
      updateStatus();
      draw();
    }

    function hasTerritories(player) {
      return territories.some(t => t.owner === player);
    }

    /**********************************
     * GAME OVER CHECK
     **********************************/
    function checkGameOver() {
      const owners = new Set(
        territories
          .filter(t => t.owner >= 0) // ignore water/ruins
          .map(t => t.owner)
      );
      if (owners.size === 1) {
        gameOver = true;
        [winner] = owners;
      }
    }

    /**********************************
     * REINFORCEMENTS
     **********************************/
    function reinforce(player) {
      for (let i = 0; i < territories.length; i++) {
        if (territories[i].owner === player) {
          territories[i].dice++;
        }
      }
    }

    /**********************************
     * HUMAN INTERACTION
     **********************************/
    canvas.addEventListener('click', (evt) => {
      if (gameOver || currentPlayer !== 0 || anim) return;

      const rect = canvas.getBoundingClientRect();
      const mx = evt.clientX - rect.left;
      const my = evt.clientY - rect.top;

      const clicked = pixelToHex(mx, my);
      if (!clicked) return;
      const { r, c } = clicked;
      if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
      const idx = r * COLS + c;
      const cell = territories[idx];

      // Select/deselect your own land with ≥2 dice
      if (cell.owner === 0 && cell.dice > 1) {
        selectedIndex = (selectedIndex === idx) ? null : idx;
        draw();
        return;
      }

      // If a hex is selected, attempt to attack neighbor (enemy or ruin)
      if (selectedIndex !== null) {
        const fromIdx = selectedIndex;
        const toIdx = idx;
        const fromCell = territories[fromIdx];
        const toCell = territories[toIdx];
        if (
          fromCell.owner === 0 &&
          toCell.owner !== 0 &&       // not your own
          toCell.owner !== -1 &&      // not water
          isNeighborHex(fromIdx, toIdx)
        ) {
          startAttackAnimation(fromIdx, toIdx);
        }
      }
    });

    endTurnBtn.addEventListener('click', endHumanTurn);

    function pixelToHex(mx, my) {
      const py = my - yOffset;
      if (py < 0) return null;
      const approxR = Math.floor(py / V_SPACING);
      const row = approxR;
      if (row < 0 || row >= ROWS) return null;
      const px = mx - xOffset;
      const rowOffsetX = (row % 2 === 1) ? (HEX_WIDTH / 2) : 0;
      const approxC = Math.floor((px - rowOffsetX) / HEX_WIDTH);
      const col = approxC;
      if (col < 0 || col >= COLS) return null;

      let best = null, bestDist = Infinity;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          const nr = row + dr;
          const nc = col + dc + ((row % 2 === 1 && (dr === -1 || dr === 1)) ? 1 : 0);
          if (
            nr < 0 || nr >= ROWS ||
            nc < 0 || nc >= COLS
          ) continue;
          const { centerX, centerY } = hexCenter(nr, nc);
          const dx = mx - centerX;
          const dy = my - centerY;
          const dist = Math.hypot(dx, dy);
          if (
            dist < bestDist &&
            pointInHexagon(mx, my, centerX, centerY, HEX_RADIUS)
          ) {
            bestDist = dist;
            best = { r: nr, c: nc };
          }
        }
      }
      if (!best) {
        const { centerX, centerY } = hexCenter(row, col);
        if (pointInHexagon(mx, my, centerX, centerY, HEX_RADIUS)) {
          return { r: row, c: col };
        }
        return null;
      }
      return best;
    }

    function pointInHexagon(px, py, cx, cy, r) {
      const dx = Math.abs(px - cx) / r;
      const dy = Math.abs(py - cy) / r;
      if (dy > 1) return false;
      return (Math.sqrt(3) * dx + dy <= Math.sqrt(3));
    }

    /**********************************
     * ATTACK ANIMATION & RESOLUTION
     **********************************/
    function startAttackAnimation(attackerIdx, defenderIdx) {
      const A_dice = territories[attackerIdx].dice;
      const D_dice = territories[defenderIdx].dice;
      const finalAttackerRolls = Array.from(
        { length: A_dice },
        () => Math.floor(Math.random() * 6) + 1
      );
      const finalDefenderRolls = Array.from(
        { length: D_dice },
        () => Math.floor(Math.random() * 6) + 1
      );
      const attackerSum = finalAttackerRolls.reduce((s, v) => s + v, 0);
      const defenderSum = finalDefenderRolls.reduce((s, v) => s + v, 0);

      anim = {
        attackerIdx,
        defenderIdx,
        framesLeft: ANIM_FRAMES,
        A_dice,
        D_dice,
        finalAttackerRolls,
        finalDefenderRolls,
        attackerSum,
        defenderSum,
        finalDisplayed: false
      };
      updateStatus();
    }

    function drawDiceAnimation() {
      if (!anim) return;
      const {
        attackerIdx, defenderIdx,
        framesLeft, A_dice, D_dice,
        finalAttackerRolls, finalDefenderRolls,
        attackerSum, defenderSum,
        finalDisplayed
      } = anim;

      const attackerPos = hexCenter(
        Math.floor(attackerIdx / COLS),
        attackerIdx % COLS
      );
      const defenderPos = hexCenter(
        Math.floor(defenderIdx / COLS),
        defenderIdx % COLS
      );

      const baseDieSize = Math.min(HEX_RADIUS * 1.4, 50);
      const spacing = 8;

      if (framesLeft > 1) {
        const dieSize = baseDieSize;
        // Attacker dice above
        const totalWidthA = A_dice * dieSize + (A_dice - 1) * spacing;
        const startXA = attackerPos.centerX - totalWidthA / 2;
        const yA = attackerPos.centerY - HEX_RADIUS - dieSize - 10;
        for (let i = 0; i < A_dice; i++) {
          const x = startXA + i * (dieSize + spacing);
          const face = Math.floor(Math.random() * 6) + 1;
          drawSingleDie(x, yA, dieSize, face, false);
        }
        // Defender dice below
        const totalWidthD = D_dice * dieSize + (D_dice - 1) * spacing;
        const startXD = defenderPos.centerX - totalWidthD / 2;
        const yD = defenderPos.centerY + HEX_RADIUS + 10;
        for (let i = 0; i < D_dice; i++) {
          const x = startXD + i * (dieSize + spacing);
          const face = Math.floor(Math.random() * 6) + 1;
          drawSingleDie(x, yD, dieSize, face, false);
        }
        anim.framesLeft--;
      } else {
        // Final frame: show actual with colored borders
        if (!finalDisplayed) {
          anim.finalDisplayed = true;
          const dieSize = baseDieSize * 1.2;
          // Attacker dice
          const totalWidthA = A_dice * dieSize + (A_dice - 1) * spacing;
          const startXA = attackerPos.centerX - totalWidthA / 2;
          const yA = attackerPos.centerY - HEX_RADIUS - dieSize - 10;
          const attackerWon = attackerSum > defenderSum;
          for (let i = 0; i < A_dice; i++) {
            const x = startXA + i * (dieSize + spacing);
            const face = finalAttackerRolls[i];
            drawSingleDie(
              x, yA, dieSize, face,
              true,
              attackerWon ? '#00FF00' : '#FF0000'
            );
          }
          // Defender dice
          const totalWidthD = D_dice * dieSize + (D_dice - 1) * spacing;
          const startXD = defenderPos.centerX - totalWidthD / 2;
          const yD = defenderPos.centerY + HEX_RADIUS + 10;
          for (let i = 0; i < D_dice; i++) {
            const x = startXD + i * (dieSize + spacing);
            const face = finalDefenderRolls[i];
            drawSingleDie(
              x, yD, dieSize, face,
              true,
              attackerWon ? '#FF0000' : '#00FF00'
            );
          }

          // Show banner with outcome
          const humanIsAttacker = (currentPlayer === 0);
          let message = '';
          if (humanIsAttacker) {
            if (attackerWon) {
              message = `You win the roll (${attackerSum} vs ${defenderSum})`;
            } else {
              message = `You lose the roll (${attackerSum} vs ${defenderSum})`;
            }
          } else {
            // AI attacking
            const defenderOwner = territories[defenderIdx].owner;
            const defenderIsHuman = (defenderOwner === 0);
            if (defenderIsHuman) {
              if (attackerWon) {
                message = `AI Player ${currentPlayer + 1} (${AI_PERSONALITIES[currentPlayer]}) wins the roll (${attackerSum} vs ${defenderSum})`;
              } else {
                message = `You defend successfully (${defenderSum} vs ${attackerSum})`;
              }
            } else {
              // AI vs AI or AI capturing ruin
              if (territories[defenderIdx].owner === -2) {
                if (attackerWon) {
                  message = `AI Player ${currentPlayer + 1} captured a ruin! (${attackerSum} vs ${defenderSum})`;
                } else {
                  message = `Ruin defended itself (${defenderSum} vs ${attackerSum})`;
                }
              } else {
                // AI vs AI
                if (attackerWon) {
                  message = `AI Player ${currentPlayer + 1} wins the roll (${attackerSum} vs ${defenderSum})`;
                } else {
                  message = `AI Player ${defenderOwner + 1} defends (${defenderSum} vs ${attackerSum})`;
                }
              }
            }
          }
          if (message) showDiceResult(message);

          // After 1 second, resolve
          setTimeout(() => {
            resolveAttack(attackerIdx, defenderIdx, attackerSum, defenderSum);
          }, 1000);
        }
      }
    }

    function drawSingleDie(x, y, size, face, highlight, borderColor) {
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);

      if (highlight) {
        ctx.strokeStyle = borderColor || '#FFD700';
        ctx.lineWidth = 4;
      } else {
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
      }
      ctx.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);

      ctx.fillStyle = '#000000';
      ctx.font = `${Math.floor(size * 0.6)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(face, x + size / 2, y + size / 2 + 1);
    }

    function resolveAttack(attackerIdx, defenderIdx, attackerSum, defenderSum) {
      const A = territories[attackerIdx];
      const D = territories[defenderIdx];

      if (attackerSum > defenderSum) {
        // Conquer
        const movedDice = A.dice - 1;
        const oldOwner = D.owner;
        territories[defenderIdx].owner = currentPlayer;
        territories[defenderIdx].dice = movedDice > 0 ? movedDice : 1;
        A.dice = 1;
        if (oldOwner >= 0) checkElimination(oldOwner);
      } else {
        // Penalty: lose all but one die
        A.dice = 1;
      }

      anim = null;
      checkGameOver();
      draw();
      updateStatus();
    }

    function checkElimination(loser) {
      if (loser < 0 || loser >= NUM_PLAYERS) return;
      if (!hasTerritories(loser)) {
        // Eliminated
      }
    }

    /**********************************
     * HEX NEIGHBOR LOGIC
     **********************************/
    function isNeighborHex(idx1, idx2) {
      const r1 = Math.floor(idx1 / COLS), c1 = idx1 % COLS;
      const r2 = Math.floor(idx2 / COLS), c2 = idx2 % COLS;
      const dr = r2 - r1, dc = c2 - c1;

      if (dr === 0 && Math.abs(dc) === 1) return true;
      if (r1 % 2 === 0) {
        if (dr === -1 && (dc === 0 || dc === -1)) return true;
        if (dr ===  1 && (dc === 0 || dc === -1)) return true;
      } else {
        if (dr === -1 && (dc === 1 || dc === 0)) return true;
        if (dr ===  1 && (dc === 1 || dc === 0)) return true;
      }
      return false;
    }

    function getNeighborsHex(idx) {
      const r = Math.floor(idx / COLS), c = idx % COLS;
      const results = [];
      if (c + 1 < COLS) results.push(r * COLS + (c + 1));
      if (c - 1 >= 0)  results.push(r * COLS + (c - 1));

      if (r % 2 === 0) {
        if (r - 1 >= 0) {
          if (c < COLS)   results.push((r - 1) * COLS + c);
          if (c - 1 >= 0) results.push((r - 1) * COLS + (c - 1));
        }
        if (r + 1 < ROWS) {
          if (c < COLS)   results.push((r + 1) * COLS + c);
          if (c - 1 >= 0) results.push((r + 1) * COLS + (c - 1));
        }
      } else {
        if (r - 1 >= 0) {
          if (c + 1 < COLS) results.push((r - 1) * COLS + (c + 1));
          results.push((r - 1) * COLS + c);
        }
        if (r + 1 < ROWS) {
          if (c + 1 < COLS) results.push((r + 1) * COLS + (c + 1));
          results.push((r + 1) * COLS + c);
        }
      }
      return results;
    }

    /**********************************
     * AI TURN & PERSONALITIES
     **********************************/
    function aiTurn(aiPlayer) {
      if (gameOver || aiPlayer === 0) return;

      const personality = AI_PERSONALITIES[aiPlayer];
      let validAttacks = [];

      // Scavenger: prioritize adjacent ruins
      if (personality === 'Scavenger') {
        for (let i = 0; i < territories.length; i++) {
          if (territories[i].owner !== aiPlayer || territories[i].dice < 2) continue;
          const nbrs = getNeighborsHex(i);
          for (const j of nbrs) {
            if (territories[j].owner === -2) {
              validAttacks = [{ attacker: i, defender: j }];
              break;
            }
          }
          if (validAttacks.length) break;
        }
        if (validAttacks.length === 0) {
          validAttacks = collectOpportunistAttacks(aiPlayer);
        }
      } else if (personality === 'Aggressor') {
        validAttacks = collectAggressorAttacks(aiPlayer);
      } else if (personality === 'Opportunist') {
        validAttacks = collectOpportunistAttacks(aiPlayer);
      } else if (personality === 'Turtle') {
        // Turtle: no attack, only reinforce
        reinforce(aiPlayer);
        advanceToNextPlayer();
        return;
      } else {
        validAttacks = collectAggressorAttacks(aiPlayer);
      }

      if (validAttacks.length === 0) {
        reinforce(aiPlayer);
        advanceToNextPlayer();
        return;
      }

      const choice = validAttacks[Math.floor(Math.random() * validAttacks.length)];
      const { attacker, defender } = choice;
      const attDiceCount = territories[attacker].dice;
      const defDiceCount = territories[defender].dice;

      const attRollSum = rollDiceSum(attDiceCount);
      const defRollSum = rollDiceSum(defDiceCount);

      if (attRollSum > defRollSum) {
        const movedDice = attDiceCount - 1;
        const oldOwner = territories[defender].owner;
        territories[defender].owner = aiPlayer;
        territories[defender].dice = movedDice > 0 ? movedDice : 1;
        territories[attacker].dice = 1;
        if (oldOwner >= 0) checkElimination(oldOwner);
      } else {
        // Penalty: lose all but one die
        territories[attacker].dice = 1;
      }

      setTimeout(() => {
        if (!gameOver) aiTurn(aiPlayer);
        else advanceToNextPlayer();
      }, 100);
    }

    function collectAggressorAttacks(player) {
      const attacks = [];
      for (let i = 0; i < territories.length; i++) {
        const cell = territories[i];
        if (cell.owner !== player || cell.dice <= 1) continue;
        const nbrs = getNeighborsHex(i);
        for (const j of nbrs) {
          const neighbor = territories[j];
          // If neighbor is human (0), attack whenever cell.dice > 1
          if (neighbor.owner === 0 && cell.dice > 1) {
            attacks.push({ attacker: i, defender: j });
          }
          // Otherwise, existing condition
          else if (neighbor.owner >= 1 && neighbor.owner !== player && cell.dice >= neighbor.dice) {
            attacks.push({ attacker: i, defender: j });
          }
          // Ruin capture
          if (neighbor.owner === -2 && cell.dice >= 2) {
            attacks.push({ attacker: i, defender: j });
          }
        }
      }
      return attacks;
    }

    function collectOpportunistAttacks(player) {
      const attacks = [];
      for (let i = 0; i < territories.length; i++) {
        const cell = territories[i];
        if (cell.owner !== player || cell.dice <= 1) continue;
        const nbrs = getNeighborsHex(i);
        for (const j of nbrs) {
          const neighbor = territories[j];
          // If neighbor is human, require only cell.dice > competitor.dice - 1 (i.e., one-die advantage)
          if (neighbor.owner === 0 && cell.dice >= neighbor.dice + 1) {
            attacks.push({ attacker: i, defender: j });
          }
          else if (neighbor.owner >= 1 && neighbor.owner !== player && cell.dice >= neighbor.dice + 2) {
            attacks.push({ attacker: i, defender: j });
          }
          // Ruin capture
          if (neighbor.owner === -2 && cell.dice >= 3) {
            attacks.push({ attacker: i, defender: j });
          }
        }
      }
      return attacks;
    }

    function rollDiceSum(count) {
      let sum = 0;
      for (let i = 0; i < count; i++) {
        sum += Math.floor(Math.random() * 6) + 1;
      }
      return sum;
    }

    /**********************************
     * DICE RESULT BANNER
     **********************************/
    function showDiceResult(message) {
      diceResultDiv.textContent = message;
      diceResultDiv.classList.add('show');
      setTimeout(() => {
        diceResultDiv.classList.remove('show');
      }, 2000);
    }

    /**********************************
     * START GAME LOOP
     **********************************/
    initGame();
    setInterval(draw, 1000 / FPS);

    /**********************************
     * EVENT HANDLERS FOR CONTROLS
     **********************************/
    newMapBtn.addEventListener('click', () => {
      const aiCount = parseInt(aiCountSelect.value, 10);
      NUM_PLAYERS = 1 + aiCount;
      initGame();
    });

  })();
  </script>
</body>
</html>
